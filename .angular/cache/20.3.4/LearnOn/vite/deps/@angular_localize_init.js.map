{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/localize/fesm2022/localize2.mjs", "../../../../../../node_modules/@angular/localize/fesm2022/init.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v20.3.3\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n/**\r\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\r\n * A block can indicate metadata about the message or specify a name of a placeholder for a\r\n * substitution expressions.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize`Hello, ${title}:title:!`;\r\n * $localize`:meaning|description@@id:source message text`;\r\n * ```\r\n */\r\nconst BLOCK_MARKER$1 = ':';\r\n/**\r\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\r\n * $localize `:movement|Button label for moving to the right: Right!`;\r\n * ```\r\n */\r\nconst MEANING_SEPARATOR = '|';\r\n/**\r\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\r\n * ```\r\n */\r\nconst ID_SEPARATOR = '@@';\r\n/**\r\n * The marker used to separate legacy message ids from the rest of a metadata block.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\r\n * ```\r\n *\r\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\r\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\r\n *\r\n * Here is some background for the original \"unit separator character\":\r\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\r\n */\r\nconst LEGACY_ID_INDICATOR = '\\u241F';\r\n\r\n/**\r\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\r\n */\r\nlet textEncoder;\r\n/**\r\n * Compute the fingerprint of the given string\r\n *\r\n * The output is 64 bit number encoded as a decimal string\r\n *\r\n * based on:\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\r\n */\r\nfunction fingerprint(str) {\r\n    textEncoder ??= new TextEncoder();\r\n    const utf8 = textEncoder.encode(str);\r\n    const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\r\n    let hi = hash32(view, utf8.length, 0);\r\n    let lo = hash32(view, utf8.length, 102072);\r\n    if (hi == 0 && (lo == 0 || lo == 1)) {\r\n        hi = hi ^ 0x130f9bef;\r\n        lo = lo ^ -0x6b5f56d8;\r\n    }\r\n    return (BigInt.asUintN(32, BigInt(hi)) << BigInt(32)) | BigInt.asUintN(32, BigInt(lo));\r\n}\r\nfunction computeMsgId(msg, meaning = '') {\r\n    let msgFingerprint = fingerprint(msg);\r\n    if (meaning) {\r\n        // Rotate the 64-bit message fingerprint one bit to the left and then add the meaning\r\n        // fingerprint.\r\n        msgFingerprint =\r\n            BigInt.asUintN(64, msgFingerprint << BigInt(1)) |\r\n                ((msgFingerprint >> BigInt(63)) & BigInt(1));\r\n        msgFingerprint += fingerprint(meaning);\r\n    }\r\n    return BigInt.asUintN(63, msgFingerprint).toString();\r\n}\r\nfunction hash32(view, length, c) {\r\n    let a = 0x9e3779b9, b = 0x9e3779b9;\r\n    let index = 0;\r\n    const end = length - 12;\r\n    for (; index <= end; index += 12) {\r\n        a += view.getUint32(index, true);\r\n        b += view.getUint32(index + 4, true);\r\n        c += view.getUint32(index + 8, true);\r\n        const res = mix(a, b, c);\r\n        (a = res[0]), (b = res[1]), (c = res[2]);\r\n    }\r\n    const remainder = length - index;\r\n    // the first byte of c is reserved for the length\r\n    c += length;\r\n    if (remainder >= 4) {\r\n        a += view.getUint32(index, true);\r\n        index += 4;\r\n        if (remainder >= 8) {\r\n            b += view.getUint32(index, true);\r\n            index += 4;\r\n            // Partial 32-bit word for c\r\n            if (remainder >= 9) {\r\n                c += view.getUint8(index++) << 8;\r\n            }\r\n            if (remainder >= 10) {\r\n                c += view.getUint8(index++) << 16;\r\n            }\r\n            if (remainder === 11) {\r\n                c += view.getUint8(index++) << 24;\r\n            }\r\n        }\r\n        else {\r\n            // Partial 32-bit word for b\r\n            if (remainder >= 5) {\r\n                b += view.getUint8(index++);\r\n            }\r\n            if (remainder >= 6) {\r\n                b += view.getUint8(index++) << 8;\r\n            }\r\n            if (remainder === 7) {\r\n                b += view.getUint8(index++) << 16;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // Partial 32-bit word for a\r\n        if (remainder >= 1) {\r\n            a += view.getUint8(index++);\r\n        }\r\n        if (remainder >= 2) {\r\n            a += view.getUint8(index++) << 8;\r\n        }\r\n        if (remainder === 3) {\r\n            a += view.getUint8(index++) << 16;\r\n        }\r\n    }\r\n    return mix(a, b, c)[2];\r\n}\r\nfunction mix(a, b, c) {\r\n    a -= b;\r\n    a -= c;\r\n    a ^= c >>> 13;\r\n    b -= c;\r\n    b -= a;\r\n    b ^= a << 8;\r\n    c -= a;\r\n    c -= b;\r\n    c ^= b >>> 13;\r\n    a -= b;\r\n    a -= c;\r\n    a ^= c >>> 12;\r\n    b -= c;\r\n    b -= a;\r\n    b ^= a << 16;\r\n    c -= a;\r\n    c -= b;\r\n    c ^= b >>> 5;\r\n    a -= b;\r\n    a -= c;\r\n    a ^= c >>> 3;\r\n    b -= c;\r\n    b -= a;\r\n    b ^= a << 10;\r\n    c -= a;\r\n    c -= b;\r\n    c ^= b >>> 15;\r\n    return [a, b, c];\r\n}\r\n// Utils\r\nvar Endian;\r\n(function (Endian) {\r\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\r\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\r\n})(Endian || (Endian = {}));\r\n\r\n// This module specifier is intentionally a relative path to allow bundling the code directly\r\n// into the package.\r\n// @ng_package: ignore-cross-repo-import\r\n/**\r\n * Parse a `$localize` tagged string into a structure that can be used for translation or\r\n * extraction.\r\n *\r\n * See `ParsedMessage` for an example.\r\n */\r\nfunction parseMessage(messageParts, expressions, location, messagePartLocations, expressionLocations = []) {\r\n    const substitutions = {};\r\n    const substitutionLocations = {};\r\n    const associatedMessageIds = {};\r\n    const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\r\n    const cleanedMessageParts = [metadata.text];\r\n    const placeholderNames = [];\r\n    let messageString = metadata.text;\r\n    for (let i = 1; i < messageParts.length; i++) {\r\n        const { messagePart, placeholderName = computePlaceholderName(i), associatedMessageId, } = parsePlaceholder(messageParts[i], messageParts.raw[i]);\r\n        messageString += `{$${placeholderName}}${messagePart}`;\r\n        if (expressions !== undefined) {\r\n            substitutions[placeholderName] = expressions[i - 1];\r\n            substitutionLocations[placeholderName] = expressionLocations[i - 1];\r\n        }\r\n        placeholderNames.push(placeholderName);\r\n        if (associatedMessageId !== undefined) {\r\n            associatedMessageIds[placeholderName] = associatedMessageId;\r\n        }\r\n        cleanedMessageParts.push(messagePart);\r\n    }\r\n    const messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\r\n    const legacyIds = metadata.legacyIds ? metadata.legacyIds.filter((id) => id !== messageId) : [];\r\n    return {\r\n        id: messageId,\r\n        legacyIds,\r\n        substitutions,\r\n        substitutionLocations,\r\n        text: messageString,\r\n        customId: metadata.customId,\r\n        meaning: metadata.meaning || '',\r\n        description: metadata.description || '',\r\n        messageParts: cleanedMessageParts,\r\n        messagePartLocations,\r\n        placeholderNames,\r\n        associatedMessageIds,\r\n        location,\r\n    };\r\n}\r\n/**\r\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\r\n *\r\n * If the message part has a metadata block this function will extract the `meaning`,\r\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\r\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\r\n *\r\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * `:meaning|description@@custom-id:`\r\n * `:meaning|@@custom-id:`\r\n * `:meaning|description:`\r\n * `:description@@custom-id:`\r\n * `:meaning|:`\r\n * `:description:`\r\n * `:@@custom-id:`\r\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`\r\n * ```\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns A object containing any metadata that was parsed from the message part.\r\n */\r\nfunction parseMetadata(cooked, raw) {\r\n    const { text: messageString, block } = splitBlock(cooked, raw);\r\n    if (block === undefined) {\r\n        return { text: messageString };\r\n    }\r\n    else {\r\n        const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\r\n        const [meaningAndDesc, customId] = meaningDescAndId.split(ID_SEPARATOR, 2);\r\n        let [meaning, description] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\r\n        if (description === undefined) {\r\n            description = meaning;\r\n            meaning = undefined;\r\n        }\r\n        if (description === '') {\r\n            description = undefined;\r\n        }\r\n        return { text: messageString, meaning, description, customId, legacyIds };\r\n    }\r\n}\r\n/**\r\n * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the\r\n * text.\r\n *\r\n * If the message part has a metadata block this function will extract the `placeholderName` and\r\n * `associatedMessageId` (if provided) from the block.\r\n *\r\n * These metadata properties are serialized in the string delimited by `@@`.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * `:placeholder-name@@associated-id:`\r\n * ```\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns A object containing the metadata (`placeholderName` and `associatedMessageId`) of the\r\n *     preceding placeholder, along with the static text that follows.\r\n */\r\nfunction parsePlaceholder(cooked, raw) {\r\n    const { text: messagePart, block } = splitBlock(cooked, raw);\r\n    if (block === undefined) {\r\n        return { messagePart };\r\n    }\r\n    else {\r\n        const [placeholderName, associatedMessageId] = block.split(ID_SEPARATOR);\r\n        return { messagePart, placeholderName, associatedMessageId };\r\n    }\r\n}\r\n/**\r\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\r\n * rest of the text of the message part.\r\n *\r\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\r\n * start and end of the block.\r\n *\r\n * If the block is in the first message part then it will be metadata about the whole message:\r\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\r\n * substitution: placeholder name.\r\n *\r\n * Since blocks are optional, it is possible that the content of a message block actually starts\r\n * with a block marker. In this case the marker must be escaped `\\:`.\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\r\n * exists.\r\n * @throws an error if the `block` is unterminated\r\n */\r\nfunction splitBlock(cooked, raw) {\r\n    if (raw.charAt(0) !== BLOCK_MARKER$1) {\r\n        return { text: cooked };\r\n    }\r\n    else {\r\n        const endOfBlock = findEndOfBlock(cooked, raw);\r\n        return {\r\n            block: cooked.substring(1, endOfBlock),\r\n            text: cooked.substring(endOfBlock + 1),\r\n        };\r\n    }\r\n}\r\nfunction computePlaceholderName(index) {\r\n    return index === 1 ? 'PH' : `PH_${index - 1}`;\r\n}\r\n/**\r\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\r\n *\r\n * @param cooked The cooked string (where escaped chars have been processed)\r\n * @param raw The raw string (where escape sequences are still in place)\r\n *\r\n * @returns the index of the end of block marker\r\n * @throws an error if the block is unterminated\r\n */\r\nfunction findEndOfBlock(cooked, raw) {\r\n    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\r\n        if (raw[rawIndex] === '\\\\') {\r\n            rawIndex++;\r\n        }\r\n        else if (cooked[cookedIndex] === BLOCK_MARKER$1) {\r\n            return cookedIndex;\r\n        }\r\n    }\r\n    throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\r\n}\r\n\r\n/**\r\n * Tag a template literal string for localization.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize `some string to localize`\r\n * ```\r\n *\r\n * **Providing meaning, description and id**\r\n *\r\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\r\n * string by pre-pending it with a colon delimited block of the form:\r\n *\r\n * ```ts\r\n * $localize`:meaning|description@@id:source message text`;\r\n *\r\n * $localize`:meaning|:source message text`;\r\n * $localize`:description:source message text`;\r\n * $localize`:@@id:source message text`;\r\n * ```\r\n *\r\n * This format is the same as that used for `i18n` markers in Angular templates. See the\r\n * [Angular i18n guide](guide/i18n/prepare#mark-text-in-component-template).\r\n *\r\n * **Naming placeholders**\r\n *\r\n * If the template literal string contains expressions, then the expressions will be automatically\r\n * associated with placeholder names for you.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize `Hi ${name}! There are ${items.length} items.`;\r\n * ```\r\n *\r\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\r\n *\r\n * The recommended practice is to name the placeholder associated with each expression though.\r\n *\r\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\r\n * expression. These placeholder names are stripped out of the rendered localized string.\r\n *\r\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\r\n *\r\n * ```ts\r\n * $localize `There are ${items.length}:itemCount: items`;\r\n * ```\r\n *\r\n * **Escaping colon markers**\r\n *\r\n * If you need to use a `:` character directly at the start of a tagged string that has no\r\n * metadata block, or directly after a substitution expression that has no name you must escape\r\n * the `:` by preceding it with a backslash:\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * // message has a metadata block so no need to escape colon\r\n * $localize `:some description::this message starts with a colon (:)`;\r\n * // no metadata block so the colon must be escaped\r\n * $localize `\\:this message starts with a colon (:)`;\r\n * ```\r\n *\r\n * ```ts\r\n * // named substitution so no need to escape colon\r\n * $localize `${label}:label:: ${}`\r\n * // anonymous substitution so colon must be escaped\r\n * $localize `${label}\\: ${}`\r\n * ```\r\n *\r\n * **Processing localized strings:**\r\n *\r\n * There are three scenarios:\r\n *\r\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\r\n * transpiler, removing the tag and replacing the template literal string with a translated\r\n * literal string from a collection of translations provided to the transpilation tool.\r\n *\r\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\r\n * reorders the parts (static strings and expressions) of the template literal string with strings\r\n * from a collection of translations loaded at run-time.\r\n *\r\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\r\n * the original template literal string without applying any translations to the parts. This\r\n * version is used during development or where there is no need to translate the localized\r\n * template literals.\r\n *\r\n * @param messageParts a collection of the static parts of the template string.\r\n * @param expressions a collection of the values of each placeholder in the template string.\r\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\r\n *\r\n * @publicApi\r\n */\r\nconst $localize = function (messageParts, ...expressions) {\r\n    if ($localize.translate) {\r\n        // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\r\n        const translation = $localize.translate(messageParts, expressions);\r\n        messageParts = translation[0];\r\n        expressions = translation[1];\r\n    }\r\n    let message = stripBlock(messageParts[0], messageParts.raw[0]);\r\n    for (let i = 1; i < messageParts.length; i++) {\r\n        message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\r\n    }\r\n    return message;\r\n};\r\nconst BLOCK_MARKER = ':';\r\n/**\r\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\r\n *\r\n * If a marker character (:) actually appears in the content at the start of a tagged string or\r\n * after a substitution expression, where a block has not been provided the character must be\r\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\r\n * messagePart, which should still contain the backslash.\r\n *\r\n * @param messagePart The cooked message part to process.\r\n * @param rawMessagePart The raw message part to check.\r\n * @returns the message part with the placeholder name stripped, if found.\r\n * @throws an error if the block is unterminated\r\n */\r\nfunction stripBlock(messagePart, rawMessagePart) {\r\n    return rawMessagePart.charAt(0) === BLOCK_MARKER\r\n        ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1)\r\n        : messagePart;\r\n}\r\n\r\nexport { $localize, BLOCK_MARKER$1 as BLOCK_MARKER, computeMsgId, findEndOfBlock, parseMessage, parseMetadata, splitBlock };\r\n\r\n", "/**\r\n * @license Angular v20.3.3\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { $localize } from './localize2.mjs';\r\n\r\n// Attach $localize to the global context, as a side-effect of this module.\r\nglobalThis.$localize = $localize;\r\n\r\nexport { $localize };\r\n\r\n"],
  "mappings": ";;;AAkBA,IAAM,iBAAiB;AAoKvB,IAAI;AAAA,CACH,SAAUA,SAAQ;AACf,EAAAA,QAAOA,QAAO,QAAQ,IAAI,CAAC,IAAI;AAC/B,EAAAA,QAAOA,QAAO,KAAK,IAAI,CAAC,IAAI;AAChC,GAAG,WAAW,SAAS,CAAC,EAAE;AAyK1B,SAAS,eAAe,QAAQ,KAAK;AACjC,WAAS,cAAc,GAAG,WAAW,GAAG,cAAc,OAAO,QAAQ,eAAe,YAAY;AAC5F,QAAI,IAAI,QAAQ,MAAM,MAAM;AACxB;AAAA,IACJ,WACS,OAAO,WAAW,MAAM,gBAAgB;AAC7C,aAAO;AAAA,IACX;AAAA,EACJ;AACA,QAAM,IAAI,MAAM,6CAA6C,GAAG,IAAI;AACxE;AAgGA,IAAM,YAAY,SAAU,iBAAiB,aAAa;AACtD,MAAI,UAAU,WAAW;AAErB,UAAM,cAAc,UAAU,UAAU,cAAc,WAAW;AACjE,mBAAe,YAAY,CAAC;AAC5B,kBAAc,YAAY,CAAC;AAAA,EAC/B;AACA,MAAI,UAAU,WAAW,aAAa,CAAC,GAAG,aAAa,IAAI,CAAC,CAAC;AAC7D,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,eAAW,YAAY,IAAI,CAAC,IAAI,WAAW,aAAa,CAAC,GAAG,aAAa,IAAI,CAAC,CAAC;AAAA,EACnF;AACA,SAAO;AACX;AACA,IAAM,eAAe;AAcrB,SAAS,WAAW,aAAa,gBAAgB;AAC7C,SAAO,eAAe,OAAO,CAAC,MAAM,eAC9B,YAAY,UAAU,eAAe,aAAa,cAAc,IAAI,CAAC,IACrE;AACV;;;ACneA,WAAW,YAAY;",
  "names": ["Endian"]
}
